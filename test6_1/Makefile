#=======================================================
# 1. 设置交叉编译前缀与内核源码路径
#=======================================================
CROSS_COMPILE ?= aarch64-linux-gnu-
KERNEL_SRC    ?= ../../build 
ARCH          ?= arm64

#=======================================================
# 2. 定义内核模块编译规则
#=======================================================
# Linux kbuild 机制：将 mydriver.o 编译成最终的 mydriver.ko
mydemo-objs := simple_char.o

obj-m	:=   mydemo.o

#=======================================================
# 3. 定义可执行文件的编译目标（test）
#=======================================================
# 在这里声明一个目标，用交叉编译工具链来编译test.c
TEST_OBJS := test

#=======================================================
# 4. 总目标：同时编译内核模块 + 可执行文件
#=======================================================
all: modules user

#-------------------------------------------------------
# 4.1 编译内核模块
#-------------------------------------------------------
modules:
	$(MAKE) -C $(KERNEL_SRC) \
		ARCH=$(ARCH) \
		CROSS_COMPILE=$(CROSS_COMPILE) \
		M=$(PWD) \
		modules

#-------------------------------------------------------
# 4.2 编译用户态程序
#-------------------------------------------------------
user: $(TEST_OBJS)

$(TEST_OBJS): test.c
	$(CROSS_COMPILE)gcc -static -o $@ $<

#-------------------------------------------------------
# 5. 清理目标
#-------------------------------------------------------
clean:
	$(MAKE) -C $(KERNEL_SRC) \
		ARCH=$(ARCH) \
		CROSS_COMPILE=$(CROSS_COMPILE) \
		M=$(PWD) \
		clean
	rm -f $(TEST_OBJS)

.PHONY: all modules user clean